---
title: "Project 1"
author: "Cass Crews"
format: html
editor: visual
---

# Introduction

# Loading in key packages

```{r}
library(tidyverse)
library(httr)
library(jsonlite)
library(stringr)
library(lubridate)
library(hms)
```

# Understanding the Census API

To obtain PUMS data via the Census API, we can take the standard approach of using `httr::GET()` and determining the correct URL structure to obtain the data we want. 

As an example, we may want to obtain educational attainment for survey respondents living in Alabama in 2022. Let's break down the corresponding URL:

> `https://api.census.gov/data/2022/acs/acs1/pums?get=PWGTP,SCHL&for=state:01`

The portion of the URL up to the "`?`" (`https://api.census.gov/data/2022/acs/acs1/pums`) indicates that we want data from the ACS 2022 1-year PUMS file. `get=PWGTP,SCHL` indicates we want the person-level weights, which we will use when generating tabulations to ensure our tabulations are representative of the Alabama population, as well as the educational attainment variable (`SCHL`). `for=state:01` indicates we only want data for Alabama. 

Let's use `GET()` to read in our data and see what we get. 

```{r}
example_data<-GET("https://api.census.gov/data/2022/acs/acs1/pums?get=PWGTP,SCHL&for=state:01")

str(example_data,max.level=1)
```

There is a lot of information returned by the Census API, but what we actually want is the raw, currently uninterpretable information in `example_data$content`. To extract these data in a usable form, we can combine the `rawToChar()` function, which will convert the raw data to human-interpretable data, with the `fromJSON()` function from the `jsonlite` package, which will convert our data to a data frame. As a final step, we can coerce our data to a tibble. This will result in cleaner printing. 

```{r}
example_mat<-fromJSON(rawToChar(example_data$content))

colnames(example_mat)<-example_mat[1,]

example_mat<-example_mat[-1,]

#example_tbl<-as_tibble(example_mat) |>
#  mutate(across(everything(),as.numeric))

example_tbl$PWGTP<-as.numeric(example_tbl$PWGTP)

example_tbl
```

This is still not particularly useful as educational attainment (`SCHL`) is a factor variable; the values have explicit meaning. Similarly, the values of `state` are all `01` rather than `Alabama`. 

Additionally, it would be nice to not need to write out all the code to complete all the post-`GET` processing each time we make an API call. To deal with this issue, let's write a helper function that completes the data processing for us. 

```{r}
content_cleaner<-function(response) {
  mat<-fromJSON(rawToChar(response$content))

  colnames(mat)<-mat[1,]
  
  mat<-mat[-1,]
  
  tbl<-as_tibble(mat)
  
  tbl$PWGTP<-as.numeric(tbl$PWGTP)
  
  return(tbl)
}
```

That should speed up the process. Let's test the function on our original API response to ensure it works.

```{r}
test_tbl<-content_cleaner(example_data)

test_tbl
```

It looks like our function worked!

# A Function to Query Census API and Clean Data

we still face the issue that our data aren't as informative as they could be. Also, it would be nice to be able to change our request and still have the resulting tibble be an informative and useful dataset. 

To solve these current limitations, let's build a comprehensive query function that allows the user to do the following:
- Select the survey year (2010 to 2023, excluding 2020)
- Select from a set of useful numeric variables, and returns    these data in the appropriate type
- Select from a set of useful categorical variables and returns these data as factor variables with appropriate levels
- Specify a geography level (All, Region, Division, or State)
- Optionally subset the data to spectific geographies within the specified         geography level

```{r}
census_get<-function(year=2022,numvar="AGEP",catvar="SEX",geo_level="state",region_select=NULL) {
  #Checking user inputs
  if (!(year %in% c(2010:2019,2021:2023))) stop("year must be between 2010 and 2023, and must not be 2020")
  if (year< 2019 & !is.null(intersect(c("JWTRNS","HISPEED"),numvar))) stop("JWTRNS and HISPEED unavailable prior to 2019")
  if (is.null(numvar)) stop("At least one numeric variable must be selected")
  
  #Building the URL
  if (geo_level=="All") { #Case where All is the specified geography
    URL<-paste0("https://api.census.gov/data/",year,"/acs/acs1/pums?get=PWGTP,",paste(numvar,collapse=","),",",paste(catvar,collapse=","))
  } else if (is.null(region_select)) { #Case where another geography is specified and no specific regions are selected
    URL<-paste0("https://api.census.gov/data/",year,"/acs/acs1/pums?get=PWGTP,",paste(numvar,collapse=","),",",paste(catvar,collapse=","),"&for=",geo_level,":*")
  } else { #Case where a subset of regions is specified
    URL<-paste0("https://api.census.gov/data/",year,"/acs/acs1/pums?get=PWGTP,",paste(numvar,collapse=","),",",paste(catvar,collapse=","),"&for=",geo_level,":",paste(region_select,collapse=","))
  }
  
  response<-GET(URL)
  
  clean_response<-content_cleaner(response)
  
  num_options<-c("AGEP","GASP","GRPIP","JWMNP")
 
  clean_response<- clean_response |>
    mutate(across(any_of(num_options),as.numeric)) 
  
  time_options<-c("JWAP","JWDP")
  
  time_vars<-intersect(time_options,numvar)
  
  for (t in time_vars) {
    metadata<-read_json(paste0("https://api.census.gov/data/",year,"/acs/acs1/pums/variables/",t,".json"))
    
    value_dict<-data.frame(levels=unlist(names(metadata$values$item)),
                           labels=unlist(metadata$values$item,use.names=FALSE))
    
    value_dict[,3:4]<-str_split_fixed(value_dict[[2]]," to ",2)
    
    value_dict[3]<-parse_hm(value_dict[[3]])
    value_dict[4]<-parse_hm(value_dict[[4]])
    
    names(value_dict)[3:4]<-c("time_1","time_2")
    
    value_dict<- value_dict |>
      mutate(secs_1=as.numeric(time_1),
             secs_2=as.numeric(time_2),
             avg_time=as_hms((secs_1+secs_2)/2)) |>
      select(levels,avg_time)
    
    names(value_dict)[1]<-t
    
    clean_response<-left_join(clean_response,value_dict,by=t)
    
    clean_response[t]<-clean_response$avg_time
    
    clean_response<- clean_response |>
      select(-avg_time)
  }
  
  #Still need to handle time variables
  
  #Still need to deal with NAs
  
  for (c in catvar) {
    metadata<-read_json(paste0("https://api.census.gov/data/",year,"/acs/acs1/pums/variables/",c,".json"))
    
    clean_response[c]<-factor(clean_response[[c]],levels=unlist(names(metadata$values$item)),labels=unlist(metadata$values$item,use.names=FALSE))
  }
  
  return(clean_response)
}

test_response<-census_get(year=2022,catvar=c("SEX","HHL"),numvar=c("AGEP","JWAP","JWDP","JWTRNS"),region_select="04")
```

