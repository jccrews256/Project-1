---
title: "Project 1"
author: "Cass Crews"
format: html
editor: visual
---

# Introduction

# Loading in key packages

```{r}
library(tidyverse)
library(httr)
library(jsonlite)
library(stringr)
library(lubridate)
library(hms)
```

# Understanding the Census API

To obtain PUMS data via the Census API, we can take the standard approach of using `httr::GET()` and determining the correct URL structure to obtain the data we want. 

As an example, we may want to obtain educational attainment for survey respondents living in Alabama in 2022. Let's break down the corresponding URL:

> `https://api.census.gov/data/2022/acs/acs1/pums?get=PWGTP,SCHL&for=state:01`

The portion of the URL up to the "`?`" (`https://api.census.gov/data/2022/acs/acs1/pums`) indicates that we want data from the ACS 2022 1-year PUMS file. `get=PWGTP,SCHL` indicates we want the person-level weights, which we will use when generating tabulations to ensure our tabulations are representative of the Alabama population, as well as the educational attainment variable (`SCHL`). `for=state:01` indicates we only want data for Alabama. 

Let's use `GET()` to read in our data and see what we get. 

```{r}
example_data<-GET("https://api.census.gov/data/2022/acs/acs1/pums?get=PWGTP,SCHL&for=state:01")

str(example_data,max.level=1)
```

There is a lot of information returned by the Census API, but what we actually want is the raw, currently uninterpretable information in `example_data$content`. To extract these data in a usable form, we can combine the `rawToChar()` function, which will convert the raw data to human-interpretable data, with the `fromJSON()` function from the `jsonlite` package, which will convert our data to a data frame. As a final step, we can coerce our data to a tibble. This will result in cleaner printing. 

```{r}
example_mat<-fromJSON(rawToChar(example_data$content))

colnames(example_mat)<-example_mat[1,]

example_mat<-example_mat[-1,]

#example_tbl<-as_tibble(example_mat) |>
#  mutate(across(everything(),as.numeric))

example_tbl$PWGTP<-as.numeric(example_tbl$PWGTP)

example_tbl
```

This is still not particularly useful as educational attainment (`SCHL`) is a factor variable; the values have explicit meaning. Similarly, the values of `state` are all `01` rather than `Alabama`. 

Additionally, it would be nice to not need to write out all the code to complete all the post-`GET` processing each time we make an API call. To deal with this issue, let's write a helper function that completes the data processing for us. 

```{r}
content_cleaner<-function(response) {
  mat<-fromJSON(rawToChar(response$content))

  colnames(mat)<-mat[1,]
  
  mat<-mat[-1,]
  
  tbl<-as_tibble(mat)
  
  tbl$PWGTP<-as.numeric(tbl$PWGTP)
  
  return(tbl)
}
```

That should speed up the process. Let's test the function on our original API response to ensure it works.

```{r}
test_tbl<-content_cleaner(example_data)

test_tbl
```

It looks like our function worked!

# A Function to Query Census API and Clean Data

we still face the issue that our data aren't as informative as they could be. Also, it would be nice to be able to change our request and still have the resulting tibble be an informative and useful dataset. 

To solve these current limitations, let's build a comprehensive query function that allows the user to do the following:
- Select the survey year (2010 to 2023, excluding 2020)
- Select from a set of useful numeric variables, and returns    these data in the appropriate type
- Select from a set of useful categorical variables and returns these data as factor variables with appropriate levels
- Specify a geography level (All, Region, Division, or State)
- Optionally subset the data to spectific geographies within the specified         geography level

```{r}
census_get<-function(year=2022,numvar="AGEP",catvar="SEX",geo_level="state",region_select="Arizona") {
  #Checking user inputs
  if (!(year %in% c(2010:2019,2021:2023))) stop("year must be between 2010 and 2023, and must not be 2020")
  if (year< 2019 & ("JWTRNS" %in% catvar)) stop("JWTRNS unavailable prior to 2019")
  if (year< 2016 & ("HISPEED" %in% catvar)) stop("HISPEED unavailable prior to 2016")
  if (is.null(numvar)) stop("At least one numeric variable must be selected")
  if(length(setdiff(numvar,c("AGEP","GASP","GRPIP","JWMNP","JWAP","JWDP")))> 0) stop("At least one numeric variable not allowed")
  if (is.null(catvar)) stop("At least one categorical variable must be selected") 
    if(length(setdiff(catvar,c("FER", "HHL", "HISPEED", "JWTRNS", "SCH", "SCHL", "SEX")))> 0) stop("At least one categorical variable not allowed")
  if (length(geo_level)> 1) stop("No more than one geographic level allowed")
  if (length(intersect(geo_level,c("all","region","division","state")))==0) stop("Invalid geography level")
  
  #Obtaining region names and codes
  if (geo_level=="state") {
    metadata_geo<-read_json(paste0("https://api.census.gov/data/2022/acs/acs1/pums/variables/ST.json"))
    
    if (!is.null(region_select)) {
      geo_dict<-data.frame(state=unlist(names(metadata_geo$values$item)),
                           labels=unlist(metadata_geo$values$item,use.names=FALSE))
      
      geo_dict$state<-as.character(as.numeric(geo_dict$state))
      
      geo_dict$labels<-word(geo_dict$labels,1,sep="/")
      
      if (length(intersect(geo_dict$labels, region_select))==0) stop("Invalid state specified")
      
      selected_geos<-geo_dict[(geo_dict$labels %in% region_select),]$state
    }
  } else if (geo_level=="region") {
    metadata_geo<-read_json(paste0("https://api.census.gov/data/",year,"/acs/acs1/pums/variables/REGION.json"))
    
    if (!is.null(region_select)) {
      geo_dict<-data.frame(region=unlist(names(metadata_geo$values$item)),
                           labels=unlist(metadata_geo$values$item,use.names=FALSE))
      
      if (length(intersect(geo_dict$labels, region_select))==0) stop("Invalid region specified")
      
      selected_geos<-geo_dict[(geo_dict$labels %in% region_select),]$region
    }    
  } else if (geo_level=="division") {
    metadata_geo<-read_json(paste0("https://api.census.gov/data/",year,"/acs/acs1/pums/variables/DIVISION.json"))
    
    if (!is.null(region_select)) {
      geo_dict<-data.frame(division=unlist(names(metadata_geo$values$item)),
                           labels=unlist(metadata_geo$values$item,use.names=FALSE))
      
      geo_dict$labels<-word(geo_dict$labels,1,sep=fixed(" ("))      
      
      if (length(intersect(geo_dict$labels, region_select))==0) stop("Invalid division specified")
      
      selected_geos<-geo_dict[(geo_dict$labels %in% region_select),]$division
    }    
  }
  
  #Building the URL
  if (geo_level=="all") { #Case where all is the specified geography
    URL<-paste0("https://api.census.gov/data/",year,"/acs/acs1/pums?get=PWGTP,",paste(numvar,collapse=","),",",paste(catvar,collapse=","))
  } else if (is.null(region_select)) { #Case where another geography is specified and no specific regions are selected
    URL<-paste0("https://api.census.gov/data/",year,"/acs/acs1/pums?get=PWGTP,",paste(numvar,collapse=","),",",paste(catvar,collapse=","),"&for=",geo_level,":*")
  } else { #Case where a subset of regions is specified
    URL<-paste0("https://api.census.gov/data/",year,"/acs/acs1/pums?get=PWGTP,",paste(numvar,collapse=","),",",paste(catvar,collapse=","),"&for=",geo_level,":",paste(selected_geos,collapse=","))
  }
  
  response<-GET(URL)
  
  clean_response<-content_cleaner(response)
  
  num_options<-c("AGEP","GASP","GRPIP","JWMNP")
 
  clean_response<- clean_response |>
    mutate(across(any_of(num_options),as.numeric)) 
  
  time_options<-c("JWAP","JWDP")
  
  time_vars<-intersect(time_options,numvar)
  
  for (t in time_vars) {
    metadata_time<-read_json(paste0("https://api.census.gov/data/",year,"/acs/acs1/pums/variables/",t,".json"))
    
    value_dict<-data.frame(levels=unlist(names(metadata_time$values$item)),
                           labels=unlist(metadata_time$values$item,use.names=FALSE))
    
    value_dict[,3:4]<-str_split_fixed(value_dict[[2]]," to ",2)
    
    value_dict[3]<-parse_hm(value_dict[[3]])
    value_dict[4]<-parse_hm(value_dict[[4]])
    
    names(value_dict)[3:4]<-c("time_1","time_2")
    
    value_dict<- value_dict |>
      mutate(secs_1=as.numeric(time_1),
             secs_2=as.numeric(time_2),
             avg_time=as_hms((secs_1+secs_2)/2)) |>
      select(levels,avg_time) |>
      rename(!!t := levels)
    
    clean_response<- clean_response |>
      left_join(value_dict,by=t) |>
      mutate(!!t := avg_time) |>
      select(-avg_time)
  }
  
  for (c in catvar) {
    metadata_cat<-read_json(paste0("https://api.census.gov/data/",year,"/acs/acs1/pums/variables/",c,".json"))
    
    clean_response[c]<-factor(clean_response[[c]],levels=unlist(names(metadata_cat$values$item)),labels=unlist(metadata_cat$values$item,use.names=FALSE))
  }
  
  
  if (geo_level=="state") clean_response$state<-as.character(as.numeric(clean_response$state))
  
  #Assigning proper names to each geography
  if (geo_level!="all") {
    clean_response<- clean_response |>
      left_join(geo_dict,by=geo_level) |>
      mutate(!!geo_level := labels) |>
      select(-labels)    
  }
  
  #Changing truly missing values to missing
  clean_response<- clean_response |>
    mutate(across(any_of(c("GRPIP","JWMNP")),~na_if(.x,0))) |>
    mutate(across(any_of("GASP"),~if_else(.x<=3,NA_real_,.x))) #Handles variations in NA coding across years
  
  return(clean_response)
}

test_response<-census_get(year=2018,catvar=c("SEX","HHL"),numvar=c("AGEP","JWAP","JWDP"),geo_level="state",region_select="Arizona")
```



```{r}
census_get_multiyear<-function(years=2021:2022,numvar="AGEP",catvar="SEX",geo_level="state",region_select="Arizona") {
  #Checking year inputs to avoid unnecessary computation
  if (length(setdiff(years,c(2010:2019,2021:2023)))> 0) stop("At least one input year not allowed")
   
  counter<-1
  for (y in years) {
    if (counter==1) {
      data<-census_get(year=y,catvar=catvar,numvar=numvar,geo_level=geo_level,region_select=region_select)
      data$year<-y
    } else {
      int_data<-census_get(year=y,catvar=catvar,numvar=numvar,geo_level=geo_level,region_select=region_select)
      int_data$year<-y
      
      data<-bind_rows(data,int_data)
    }
    counter<-counter+1
  }
  
  return(data)
}

test_response_multiyear<-census_get_multiyear(years=c(2010,2023),numvar="GASP",geo_level="division",region_select="Mountain")
```

