[
  {
    "objectID": "Project 1.html",
    "href": "Project 1.html",
    "title": "Project 1: Functions for Processing the Census Bureau’s Public Use Microdata Samples",
    "section": "",
    "text": "Introduction\nThe Public Use Microdata Samples (PUMS) from the Census Bureau provide deep insights into the socio-demographic characteristics of US residents. With a few caveats, the samples contain the individual responses from each American Community Survey, giving researchers direct access to the lived experience for one percent of US residents each year.\nWhile the data are incredibly valuable to understanding American life and its evolution, they are not particularly easy to work with. In its raw form, each annual dataset is very large and difficult to interpret. The goal of this page is to document an automated process for obtaining and processing subsets of the data, unlocking the power of the data for researchers. We begin by describing the process of obtaining the data via the PUMS Census application programming interface (API) before transitioning to the creation of a function that reads in and cleans user-specified subsets of an annual PUMS dataset. Finally, we detail the creation of a wrapper for this function that combines multiple years of cleaned data. As we proceed down the page, examples will be provided to highlight the outcomes of our work.\n\n\nLoading in Key Packages\nBefore we begin, we need to load required packages. I have printed them below, but I have suppressed all messages and warnings to preserve the tidyness of the page. After all, we are utilizing the tidyverse!\n\n#Loading required packages\nlibrary(tidyverse)\nlibrary(httr)\nlibrary(jsonlite)\nlibrary(stringr)\nlibrary(lubridate)\nlibrary(hms)\n\n\n\nUnderstanding the Census API\nTo obtain PUMS data via the API, we can take the standard approach of using httr::GET() and determining the correct URL structure to request the data we want.\nAs an example, we may want to obtain educational attainment for survey respondents living in Alabama in 2022. Let’s break down the corresponding URL:\n\nhttps://api.census.gov/data/2022/acs/acs1/pums?get=PWGTP,SCHL&for=state:01\n\nThe portion of the URL up to the ? (https://api.census.gov/data/2022/acs/acs1/pums) indicates that we want data from the ACS 2022 1-year PUMS file. get=PWGTP,SCHL,AGEP indicates we want the person-level weights (PWGTP), which we will use when generating tabulations to ensure our tabulations are representative of the Alabama population, as well as individuals’ educational attainment (SCHL) and age (AGEP). for=state:01 indicates we only want data for Alabama.\nLet’s use GET() to read in our data and see what we get.\n\n#Making a standard API call\nexample_data&lt;-\n  GET(\"https://api.census.gov/data/2022/acs/acs1/pums?get=PWGTP,SCHL,AGEP&for=state:01\")\n\n#Printing the high-level structure of the response\nstr(example_data,max.level=1)\n\nList of 10\n $ url        : chr \"https://api.census.gov/data/2022/acs/acs1/pums?get=PWGTP,SCHL,AGEP&for=state:01\"\n $ status_code: int 200\n $ headers    :List of 12\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:1189366] 5b 5b 22 50 ...\n $ date       : POSIXct[1:1], format: \"2025-10-01 23:17:59\"\n $ times      : Named num [1:6] 0 0.0472 0.0972 0.218 0.6086 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n\n\nThere is a lot of information returned by the Census API, but what we actually want is the raw, currently uninterpretable information in example_data$content. To extract these data in a usable form, we can combine the rawToChar() function, which will convert the raw data to human-interpretable data, with the fromJSON() function from the jsonlite package, which will convert our data to a matrix. As a final step, we can coerce our data to a tibble. This will result in cleaner printing.\n\n#Converting the data/content to a matrix\nexample_mat&lt;-fromJSON(rawToChar(example_data$content))\n\n#Assigning column names, which are in the first row\ncolnames(example_mat)&lt;-example_mat[1,]\nexample_mat&lt;-example_mat[-1,]\n\n#Converting to tibble and converting PWGTP to a numeric variable\nexample_tbl&lt;-as_tibble(example_mat) |&gt;\n  mutate(PWGTP=as.numeric(PWGTP))\n\n#Printing the tibble\nexample_tbl\n\n# A tibble: 51,580 × 4\n   PWGTP SCHL  AGEP  state\n   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1    69 19    85    01   \n 2    22 17    51    01   \n 3    45 11    36    01   \n 4     4 1     74    01   \n 5    47 19    49    01   \n 6    38 17    31    01   \n 7    13 19    76    01   \n 8    38 13    60    01   \n 9    66 14    35    01   \n10    31 16    72    01   \n# ℹ 51,570 more rows\n\n\nThis is still not particularly useful as educational attainment (SCHL) is a factor variable; the values are codes with explicit meaning. Similarly, the values of state are all 01 rather than Alabama.\nAdditionally, it would be nice to not need to write out all the code to complete all the post-GET processing each time we make an API call. To deal with this issue, let’s write a helper function that completes the data processing for us.\n\n#Creating an API response cleaner \"helper\" function\ncontent_cleaner&lt;-function(response) {\n  #Capturing the data in a matrix\n  mat&lt;-fromJSON(rawToChar(response$content))\n  \n  #Assigning column names (in the first row)\n  colnames(mat)&lt;-mat[1,]\n  mat&lt;-mat[-1,]\n  \n  #Converting to a tibble and converting PWGTP to numeric\n  tbl&lt;-as_tibble(mat) |&gt;\n    mutate(PWGTP=as.numeric(PWGTP))\n\n  #Returning the tibble\n  return(tbl)\n}\n\nThat should speed up the process. Let’s test the function on our original API response to ensure it works.\n\n#Applying the helper function to our initial API response\ntest_tbl&lt;-content_cleaner(example_data)\n\n#Printing the resulting tibble\ntest_tbl\n\n# A tibble: 51,580 × 4\n   PWGTP SCHL  AGEP  state\n   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1    69 19    85    01   \n 2    22 17    51    01   \n 3    45 11    36    01   \n 4     4 1     74    01   \n 5    47 19    49    01   \n 6    38 17    31    01   \n 7    13 19    76    01   \n 8    38 13    60    01   \n 9    66 14    35    01   \n10    31 16    72    01   \n# ℹ 51,570 more rows\n\n\nIt looks like our function worked!\n\n\nA Function to Query the PUMS Census API and Clean Data\nWe still face the issue that our data aren’t as informative as they could be. Also, it would be nice to be able to change our request and still have the resulting tibble be an informative and useful dataset.\nTo solve these current limitations, let’s build a comprehensive query function that allows the user to do the following:\n\nSelect the survey year\nSelect from a set of useful numeric variables, and return these data in the appropriate type\nSelect from a set of useful categorical variables and return these data as factor variables with appropriate levels\nSpecify a geography level to report\nOptionally subset the data to specific geographies within the specified geography level\n\nLet’s design the function so it returns a tibble that is informative and ready for analysis.\nThe resultant census_get() function is documented in the code chunk below. Note that there are five arguments consistent with our goals for the function:\n\nyear: The survey year we want to obtain data from, which cannot be NULL or multiple years\n\nValid Inputs are any year from 2010 to 2023, excluding 2020; the default is 2022\n\nnumvar: A vector indicating the numeric variables we want to return, which cannot be NULL. Available variables:\n\nAGEP: The age of the individual in years; this variable is selected by default\nGASP: Monthly gas cost in dollars\nGRPIP: Gross rent as a percentage of household income over the past 12 months\nJWAP: Time of arrival at work; survey respondents select from 5-minute windows, which the function converts to a single time value using the midpoint of the window\nJWDP: Time of departure for work; survey respondents select from 10-minute windows, which the function converts to a single time value using the midpoint of the window\nJWMNP: Travel time to work in minutes\n\ncatvar: A vector indicating the categorical variables we want to return. Available variables:\n\nFER: Indicates whether the individual gave birth to a child within the past 12 months\nHHL: Language spoken at home\nHISPEED: Indicates whether the individual has broadband internet service; HISPEED can only be requested for 2016 or later\nJWTRNS: Means of transportation to work; JWTRNS can only be requested for 2019 or later\nSCH: Indicates whether the individual is enrolled in school\nSCHL: Highest level of educational attainment\nSEX: The sex of the individual; this variable is selected by default\n\ngeo_level: The geography level to return. Options:\n\nall: No geography level returned\nregion: Census regions; region names available here\ndivision: Census divisions; division names available here\nstate: US states plus DC, listed here; this level is the default\n\ngeo_select: An optional vector of specific geographies of level geo_level to subset the returned data to. Use the links above to confirm geography spelling and formatting. By default the returned data are subset to individuals in Arizona.\n\nIn addition to the optional variables, PWGTP, the number of individuals each observation “represents,” is always included in the function output. This is because we need PWGTP to generate population-representative tabulations from the data.\nReaders are encouraged to review the census_get() function code for full details on function behavior. We will summarize the function steps below the code chunk.\n\n#Constructing our main data requesting and cleaning function\ncensus_get&lt;-function(year=2022,numvar=\"AGEP\",catvar=\"SEX\",geo_level=\"state\",\n                     geo_select=\"Arizona\") {\n\n  ##############################################################################  \n  #CHECKING USER INPUTS\n  ##############################################################################\n  \n  #Confirming year input\n  if (!(year %in% c(2010:2019,2021:2023))) \n    stop(\"year must be between 2010 and 2023, and must not be 2020\") \n  #Confirming JWTRNS not requested prior to 2019\n  if (year&lt; 2019 & (\"JWTRNS\" %in% catvar)) \n    stop(\"JWTRNS unavailable prior to 2019\") \n  #Confirming HISPEED not requested prior to 2016\n  if (year&lt; 2016 & (\"HISPEED\" %in% catvar)) \n    stop(\"HISPEED unavailable prior to 2016\") \n  #Confirming numvar not set to NULL\n  if (is.null(numvar)) \n    stop(\"At least one numeric variable must be selected\") \n  #Confirming all numvar inputs are valid\n  if(length(setdiff(numvar,c(\"AGEP\",\"GASP\",\"GRPIP\",\"JWMNP\",\"JWAP\",\"JWDP\")))&gt; 0) \n    stop(\"At least one numeric variable not allowed\") \n  #Confirming catvar not set to NULL\n  if (is.null(catvar)) \n    stop(\"At least one categorical variable must be selected\") \n  #Confirming all catvar inputs are valid\n  if(length(setdiff(catvar,c(\"FER\", \"HHL\", \"HISPEED\", \"JWTRNS\", \"SCH\",\n                             \"SCHL\", \"SEX\")))&gt; 0) \n    stop(\"At least one categorical variable not allowed\") \n  #Confirming only one geo level specified\n  if (length(geo_level)&gt; 1) \n    stop(\"No more than one geographic level allowed\") \n  #Confirming geo_level not set to NULL\n  if (is.null(geo_level)) \n    stop(\"Must specify a geographic level\") \n  #Confirming geo_level input is valid\n  if (length(intersect(geo_level,c(\"all\",\"region\",\"division\",\"state\")))==0) \n    stop(\"Invalid geography level\") \n\n  \n  ##############################################################################\n  #BUILDING THE URL AND MAKING API CALL\n  ##############################################################################\n\n  #CONVERTING geo_level TO CODES FOR GET URL SPECIFICATION######################  \n  \n  #Handling state case\n  if (geo_level==\"state\") {\n    #Reading in state variable metadata\n    ##Using 2022 as metadata not provided in all years\n    metadata_geo&lt;-\n      read_json(paste0(\"https://api.census.gov/data/2022/acs/acs1/pums/variables/ST.json\"))\n    \n    #Capturing state fips codes and labels\n    geo_dict&lt;-data.frame(state=unlist(names(metadata_geo$values$item)),\n                          labels=unlist(metadata_geo$values$item,use.names=FALSE))\n    \n    #Stripping labels down to only state names \n    #(originally include postal abbreviations)  \n    geo_dict$labels&lt;-word(geo_dict$labels,1,sep=\"/\")\n    \n    #When state subset specified, capturing corresponding FIPS codes for GET URL\n    if (!is.null(geo_select)) {\n      if (length(intersect(geo_dict$labels, geo_select))==0) \n        stop(\"Invalid state specified\") #Confirming supplied states are valid\n      \n      #Capturing FIPS codes\n      selected_geos&lt;-geo_dict[(geo_dict$labels %in% geo_select),]$state\n    }\n    \n    #Removing leading zeroes to protect against code format changes across years\n    #Used later for state labeling \n    geo_dict$state&lt;-as.character(as.numeric(geo_dict$state))\n    \n  #Handling region case\n  } else if (geo_level==\"region\") {\n    #Reading in region variable metadata    \n    metadata_geo&lt;-read_json(paste0(\"https://api.census.gov/data/\",year,\n                                   \"/acs/acs1/pums/variables/REGION.json\"))\n    \n    #Capturing the region codes and labels\n    geo_dict&lt;-data.frame(region=unlist(names(metadata_geo$values$item)),\n                          labels=unlist(metadata_geo$values$item,use.names=FALSE))    \n\n    #When region subset specified, capturing corresponding codes for GET URL    \n    if (!is.null(geo_select)) {\n      if (length(intersect(geo_dict$labels, geo_select))==0) \n        stop(\"Invalid region specified\") #Confirming supplied regions are valid\n\n      #Capturing region codes      \n      selected_geos&lt;-geo_dict[(geo_dict$labels %in% geo_select),]$region\n    } \n    \n  #Handling division case\n  } else if (geo_level==\"division\") {\n    #Reading in division variable metadata\n    metadata_geo&lt;-read_json(paste0(\"https://api.census.gov/data/\",year,\n                                   \"/acs/acs1/pums/variables/DIVISION.json\"))\n    \n    #Capturing the division codes and labels\n    geo_dict&lt;-data.frame(division=unlist(names(metadata_geo$values$item)),\n                          labels=unlist(metadata_geo$values$item,use.names=FALSE))\n    \n    #Stripping labels down to only division names \n    #(Also indicates corresponding region for 2021:2023)  \n    geo_dict$labels&lt;-word(geo_dict$labels,1,sep=fixed(\" (\"))       \n\n    #When division subset specified, capturing corresponding codes for GET URL\n    if (!is.null(geo_select)) {\n      if (length(intersect(geo_dict$labels, geo_select))==0) \n        stop(\"Invalid division specified\") #Confirming supplied divisions are valid\n      \n      #Capturing division codes\n      selected_geos&lt;-geo_dict[(geo_dict$labels %in% geo_select),]$division\n    }    \n  }\n  \n  \n  #CONSTRUCTING THE URL AND MAKING THE CALL#####################################\n  \n  #Building the URL when all is the specified geography\n  if (geo_level==\"all\") { \n    URL&lt;-paste0(\"https://api.census.gov/data/\",year,\"/acs/acs1/pums?get=PWGTP,\",\n                paste(numvar,collapse=\",\"),\",\",paste(catvar,collapse=\",\"))\n  #Building URL when another geography is specified and no specific regions \n    #are selected\n  } else if (is.null(geo_select)) { \n    URL&lt;-paste0(\"https://api.census.gov/data/\",year,\"/acs/acs1/pums?get=PWGTP,\",\n                paste(numvar,collapse=\",\"),\",\",paste(catvar,collapse=\",\"),\"&for=\",\n                geo_level,\":*\")\n  #Building URL when a subset of regions is specified\n  } else { \n    URL&lt;-paste0(\"https://api.census.gov/data/\",year,\"/acs/acs1/pums?get=PWGTP,\",\n                paste(numvar,collapse=\",\"),\",\",paste(catvar,collapse=\",\"),\"&for=\",\n                geo_level,\":\",paste(selected_geos,collapse=\",\"))\n  }\n  \n  #Making API Call\n  response&lt;-GET(URL)\n  \n\n  \n  ##############################################################################\n  #DATA CLEANING\n  ##############################################################################  \n  \n  #APPLYING content_cleaner HELPER FUNCTION#####################################\n  \n  #Applying content_cleaner helper function\n  clean_response&lt;-content_cleaner(response)\n  \n  \n  #CONVERTING NUMERIC VARIABLES TO NUMERIC TYPE#################################\n  \n  #Specifying potential truly numeric variable selections\n  num_options&lt;-c(\"AGEP\",\"GASP\",\"GRPIP\",\"JWMNP\")\n \n  #Converting numeric variables to numeric type\n  clean_response&lt;- clean_response |&gt;\n    mutate(across(any_of(num_options),as.numeric)) \n\n  \n  #TIME VARIABLE PROCESSING#####################################################\n    \n  #Specifying potential time variable selections\n  time_options&lt;-c(\"JWAP\",\"JWDP\")\n  \n  #Identifying time variables specified by user\n  time_vars&lt;-intersect(time_options,numvar)\n  \n  #Looping across selected time variables to extract midpoint time values\n  #for time ranges and incorporating into dataset\n  for (t in time_vars) {\n    #Reading in variable metadata\n    metadata_time&lt;-read_json(paste0(\"https://api.census.gov/data/\",year,\n                                    \"/acs/acs1/pums/variables/\",t,\".json\"))\n    \n    #Capturing variable codes and labels\n    value_dict&lt;-data.frame(levels=unlist(names(metadata_time$values$item)),\n                           labels=unlist(metadata_time$values$item,use.names=FALSE))\n    \n    #Capturing time range endpoints\n    value_dict[,3:4]&lt;-str_split_fixed(value_dict[[2]],\" to \",2)\n    \n    #Converting endpoints to true time data\n    value_dict[3]&lt;-parse_hm(value_dict[[3]])\n    value_dict[4]&lt;-parse_hm(value_dict[[4]])\n    \n    #Assigning endpoint names\n    names(value_dict)[3:4]&lt;-c(\"time_1\",\"time_2\")\n    \n    #Calculating midpoint between time endpoints and producing clean time \n    #value dictionary\n    value_dict&lt;- value_dict |&gt;\n      mutate(secs_1=as.numeric(time_1),\n             secs_2=as.numeric(time_2),\n             avg_time=as_hms((secs_1+secs_2)/2)) |&gt;\n      select(levels,avg_time) |&gt;\n      rename(!!t := levels)\n    \n    #Joining time midpoints to the dataset via the value codes and replacing codes\n    #with midpoints\n    clean_response&lt;- clean_response |&gt;\n      left_join(value_dict,by=t) |&gt;\n      mutate(!!t := avg_time) |&gt;\n      select(-avg_time)\n  }\n  \n  \n  #CATEGORICAL VARIABLE PROCESSING##############################################\n  \n  #Looping through categorical variables and converting to factors with appropriate\n  #labels\n  for (c in catvar) {\n    #Reading in categorical variable metadata\n    metadata_cat&lt;-read_json(paste0(\"https://api.census.gov/data/\",year,\n                                   \"/acs/acs1/pums/variables/\",c,\".json\"))\n    \n    #Using metadata (codes and labels) to convert categorical variables to factors\n    clean_response[c]&lt;-factor(clean_response[[c]],\n                              levels=unlist(names(metadata_cat$values$item)),\n                              labels=unlist(metadata_cat$values$item,use.names=FALSE))\n  }\n  \n  \n  #GEOGRAPHIC VARIABLE PROCESSING###############################################\n  \n  #Stripping leading zeroes from state FIPS codes to match codes with labels \n  #captured above in geo_dict; done to conform with code formatting changes\n  #across years\n  if (geo_level==\"state\") \n    clean_response$state&lt;-as.character(as.numeric(clean_response$state))\n  \n  #Replacing geography codes with geography names\n  if (geo_level!=\"all\") {\n    clean_response&lt;- clean_response |&gt;\n      left_join(geo_dict,by=geo_level) |&gt;\n      mutate(!!geo_level := labels) |&gt;\n      select(-labels)    \n  }\n  \n\n  #MISSING VALUE HANDLING AND RETURN SPECIFICATION##############################\n  \n  #Changing truly missing values to missing\n  #The second mutate Handles variations in NA coding across years\n  clean_response&lt;- clean_response |&gt;\n    mutate(across(any_of(c(\"GRPIP\",\"JWMNP\")),~na_if(.x,0))) |&gt;\n    mutate(across(any_of(\"GASP\"),~if_else(.x&lt;=3,NA_real_,.x))) \n  \n  #Indicating we want to return the processed dataset\n  return(clean_response)\n}\n\nThe function achieves our goals via the following general steps. First, the user inputs are thoroughly evaluated to ensure no required inputs are NULL and all specifications for year, numvar, catvar, geo_level, and geo_select are valid options. When mistakes are made, informative error messages are given so the user understands their mistake.\nSecond, the appropriate URL is constructed and the API call is made. This involves converting any geo_select inputs to the numeric codes the API can interpret, as well as incorporating the correct year and variable names into the URL.\nThird, the data are cleaned and returned. Data cleaning has the following sub-steps:\n\nOur content_cleaner() helper function is applied to the data\nThe non-time numeric variables are converted to numeric type\nTime variables are converted to time type using the midpoint of the time ranges\nCategorical variables are converted to factors with appropriate labels\nGeography names replace codes for any geography variables\nMissing value codes in numeric variables are changed to missing (NA)\n\nNow that we have the function and generally know how it works, let’s test it. To start, let’s again request educational attainment and age for individuals from Alabama in the 2022 survey.\n\n#Testing the function for the first time\nfirst_tbl&lt;-census_get(year=2022,catvar=c(\"SCHL\"),numvar=c(\"AGEP\"),\n                          geo_level=\"state\",geo_select=\"Alabama\")\n\n#Printing the results\nfirst_tbl\n\n# A tibble: 51,580 × 4\n   PWGTP  AGEP SCHL                                         state  \n   &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;                                        &lt;chr&gt;  \n 1    69    85 1 or more years of college credit, no degree Alabama\n 2    22    51 GED or alternative credential                Alabama\n 3    45    36 Grade 8                                      Alabama\n 4     4    74 &lt;NA&gt;                                         Alabama\n 5    47    49 1 or more years of college credit, no degree Alabama\n 6    38    31 GED or alternative credential                Alabama\n 7    13    76 1 or more years of college credit, no degree Alabama\n 8    38    60 Grade 10                                     Alabama\n 9    66    35 Grade 11                                     Alabama\n10    31    72 Regular high school diploma                  Alabama\n# ℹ 51,570 more rows\n\n\nThis is much better! Age is now numeric, educational attainment is easily interpreted, and we do not need to look up Alabama’s FIPS code to ensure we have the correct state.\nLet’s keep testing the function by confirming our default inputs evaluate correctly.\n\n#Testing the function with the default inputs\nsecond_tbl&lt;-census_get()\n\n#Printing the resulting tibble\nsecond_tbl\n\n# A tibble: 74,153 × 4\n   PWGTP  AGEP SEX    state  \n   &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;  &lt;chr&gt;  \n 1    37    33 Male   Arizona\n 2    94    70 Female Arizona\n 3    50    17 Female Arizona\n 4     6    16 Male   Arizona\n 5    80    82 Female Arizona\n 6    79    40 Male   Arizona\n 7    11    51 Female Arizona\n 8    55    69 Male   Arizona\n 9    58    51 Male   Arizona\n10     9    40 Male   Arizona\n# ℹ 74,143 more rows\n\n\nThis is exactly what we expected, so it looks like we correctly specified the defaults.\nNow let’s see how one of the time variables displays by adding JWAP to the request. When we print the resulting tibble, let’s subset the data to only the individuals who provided a time they arrive at work.\n\n#Testing the function when a time variable is included\nthird_tbl&lt;-census_get(numvar=c(\"AGEP\",\"JWAP\"))\n\n#Printing the tibble after subsetting to observations with non-missing time values\nthird_tbl |&gt; \n  filter(!is.na(JWAP))\n\n# A tibble: 8,165 × 5\n   PWGTP  AGEP JWAP   SEX    state  \n   &lt;dbl&gt; &lt;dbl&gt; &lt;time&gt; &lt;fct&gt;  &lt;chr&gt;  \n 1    59    21 03:52  Female Arizona\n 2     7    27 01:22  Male   Arizona\n 3    57    22 03:52  Male   Arizona\n 4     6    32 10:22  Female Arizona\n 5    13    33 10:02  Male   Arizona\n 6    51    18 04:02  Female Arizona\n 7    16    17 03:17  Male   Arizona\n 8    85    31 08:32  Male   Arizona\n 9    31    27 01:22  Male   Arizona\n10    61    19 02:02  Male   Arizona\n# ℹ 8,155 more rows\n\n\nAgain, this looks great. Not only do we have cleanly displayed times, but we have data we can analyze to understand the distribution of arrival times.\nAs a final set of checks, let’s intentionally make mistakes in our inputs to see how our error messages present. First, let’s see what happens when we request a numeric variable that is not available.\n\n#Demonstrating what happens when we misspecify a numeric variable\nnon_created_tbl1&lt;-census_get(numvar=\"DOG\")\n\nError in census_get(numvar = \"DOG\"): At least one numeric variable not allowed\n\n\nExcellent! Not only do we get an error, but we know the error is because one of the specified numeric variables is not allowed.\nNow let’s see what happens when we request data for a state that isn’t actually a state.\n\n#Demonstrating what happens when we misspecify the geography to subset to\nnon_created_tbl2&lt;-census_get(geo_select=\"Cat\")\n\nError in census_get(geo_select = \"Cat\"): Invalid state specified\n\n\nNow we know there is no US state named Cat. Good to know.\n\n\nA Function to Combine Multiple Survey Years\nWe have created a very helpful function. However, it is often the case that our analysis requires multiple years of data, such as when we want to analyze changes in age distributions across time. Let’s build a function that repeatedly deploys our census_get function for each year of data we request.\nThe arguments and defaults for this census_get_multiyear function will be identical to those of the census_get function, except that year is now years; years accepts a vector of valid year values, and its default is 2021:2022. To indicate the year an observation corresponds to, the function will include a year variable in the output tibble.\n\n#Creating the census_get wrapper function\ncensus_get_multiyear&lt;-function(years=2021:2022,numvar=\"AGEP\",catvar=\"SEX\",\n                               geo_level=\"state\",geo_select=\"Arizona\") {\n  \n  #Checking year inputs to avoid unnecessary computation if one input invalid\n  if (length(setdiff(years,c(2010:2019,2021:2023)))&gt; 0) \n    stop(\"At least one input year not allowed\")\n  \n  #Looping through years to run census_get function and append each year of data \n  counter&lt;-1\n  for (y in years) {\n    #Running census_get for first year and creating initial dataset\n    if (counter==1) {\n      data&lt;-census_get(year=y,catvar=catvar,numvar=numvar,geo_level=geo_level,\n                       geo_select=geo_select)\n      \n      #Capturing year of data\n      data$year&lt;-y\n      \n    #Running census_get for subsequent years and appending to initial dataset\n    } else {\n      int_data&lt;-census_get(year=y,catvar=catvar,numvar=numvar,geo_level=geo_level,\n                           geo_select=geo_select)\n      \n      #Capturing year of data\n      int_data$year&lt;-y\n      \n      #Appending to the existing dataset\n      data&lt;-bind_rows(data,int_data)\n    }\n    counter&lt;-counter+1 #Updating counter for if/else \n  }\n  \n  #Indicating we want the full appended dataset returned\n  return(data)\n}\n\nWe can test the function to ensure it works as intended. First, let’s request the recent birth indicator for individuals living in the Mountain census division in 2016 and 2023. We will produce two different filtered prints to ensure we obtain both years of data; we filter to each year and keep only females. We might request these data if we wanted to analyze changes in birth rates.\n\n#Testing the wrapper for the first time\nfirst_multiyr_tbl&lt;-census_get_multiyear(years=c(2016,2023),catvar=c(\"FER\",\"SEX\"),\n                                        geo_level=\"division\",geo_select=\"Mountain\")\n\n#Printing the results when year is 2016 and sex is female\nfirst_multiyr_tbl |&gt; \n  filter(year==2016,SEX==\"Female\")\n\n# A tibble: 116,021 × 6\n   PWGTP  AGEP FER                                          SEX   division  year\n   &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;                                        &lt;fct&gt; &lt;chr&gt;    &lt;dbl&gt;\n 1    48    32 No                                           Fema… Mountain  2016\n 2    68    12 N/A (less than 15 years/greater than 50 yea… Fema… Mountain  2016\n 3    68     8 N/A (less than 15 years/greater than 50 yea… Fema… Mountain  2016\n 4    13    26 No                                           Fema… Mountain  2016\n 5    83    21 No                                           Fema… Mountain  2016\n 6    94    44 No                                           Fema… Mountain  2016\n 7    85    14 N/A (less than 15 years/greater than 50 yea… Fema… Mountain  2016\n 8    90    41 No                                           Fema… Mountain  2016\n 9    82    17 No                                           Fema… Mountain  2016\n10    81    15 No                                           Fema… Mountain  2016\n# ℹ 116,011 more rows\n\n#Printing the results when year is 2016 and sex is female\nfirst_multiyr_tbl |&gt;\n  filter(year==2023,SEX==\"Female\")\n\n# A tibble: 131,840 × 6\n   PWGTP  AGEP FER                                          SEX   division  year\n   &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;                                        &lt;fct&gt; &lt;chr&gt;    &lt;dbl&gt;\n 1    39    85 N/A (less than 15 years/greater than 50 yea… Fema… Mountain  2023\n 2    63    93 N/A (less than 15 years/greater than 50 yea… Fema… Mountain  2023\n 3    73    45 No                                           Fema… Mountain  2023\n 4    75    20 No                                           Fema… Mountain  2023\n 5    70    28 No                                           Fema… Mountain  2023\n 6    18    83 N/A (less than 15 years/greater than 50 yea… Fema… Mountain  2023\n 7    12    94 N/A (less than 15 years/greater than 50 yea… Fema… Mountain  2023\n 8    91    57 N/A (less than 15 years/greater than 50 yea… Fema… Mountain  2023\n 9    47    21 No                                           Fema… Mountain  2023\n10   103    20 No                                           Fema… Mountain  2023\n# ℹ 131,830 more rows\n\n\nThe new multi-year function works as intended. Additionally, by comparing age and the recent birth indicator, we see initial evidence that our factor labeling works correctly; note that females with ages below 15 or above 50 are assigned an N/A.\nAs a final check, let’s see what happens when we request a year outside the available range.\n\n#Testing the function when we include an invalid year\nnon_created_multiyr_tbl&lt;-census_get_multiyear(years=c(2016,2024),\n                                          catvar=c(\"FER\",\"SEX\"),\n                                          geo_level=\"division\",\n                                          geo_select=\"Mountain\")\n\nError in census_get_multiyear(years = c(2016, 2024), catvar = c(\"FER\", : At least one input year not allowed\n\n\nThis worked exactly as we wanted: the function returned an error before wasting time submitting inputs to census_get.\n\n\nConclusion\nThis document explores the use of the Public Use Microdata Sample Census API to obtain individual responses to the American Community Survey. As these data require substantial work to get them into an analysis-ready form, we have created two key functions to automate the data pull and cleaning process. The first function is census_get(), which handles the data pull and cleaning process for individual survey years. The second function is census_get_multiyear(), which repeatedly deploys census_get to obtain multiple years of data in a single tibble. I hope you have found this overview of the data and functions informative, and that you find the functions useful in your future work!"
  }
]